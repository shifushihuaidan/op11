关于自增、自减运算(vc++6.0) 



1. 在不同的运行环境下，自增自减运算是有细微差别的，这里仅说明vc环境中的情况。

2. 一般情况下，自增自减的扫描顺序是从左到右。对于前增减(++i)，是以一个运算符为单位进行增减;而后增减(i++)则是以整个表达式为单位最后统一增减。
    例1：i=3;b=(++i)+(++i)+(++i);结果b=16。
分析：首先扫描求解前半部分，即(++i)+(++i)的值（先对i进行两次自增运算，i的值变为5，再计算i+i的值为5+5＝10），然后再求解后半部分，即10+(++i)的值（先对变量i自增1次，i的值变为6，再计算10+6＝16）。
    例2：i=1;b=(i++)+(++i)+(++i);结果b=7。
分析：先对第一个加法运算符两端的运算对象处理，先自增一次再求解表达式前两项(2+2=4)，然后再对i自增一次再求前一步骤的值(4)与最后一项(++i=3)的和4+3=7。

例3：i=1;a=i++,b=i+1;结果a=1,b=3。

分析：i++是以整个表达式为单位增减的，而不是以语句为单位。逗号表达式前的a=i++已经是一个表达式，所以不会是b=2。

3. 在函数中作为实参时情况又有所不同。其扫描顺序为自右向左。不过运算优先级仍存在。以printf()为例：
    例4：x=3;printf("%d,%d",++x,++x);结果5,4。
    例5：y=8,x=9;printf("%d,%d\n",(++x,y--),++x);结果8,11。
分析：Printf()中为自右向左算，但括号()的优先级在++、--和，之前。

例6：x=2;printf("%d,%d\n",(x++,x++,x++),x++);结果6,5。

分析：结果很奇怪吧！我第一次碰到时也晕了，在实验后才发现。做实参时在（）内如果只有一个表达式，那么其优先级是和没有（）时是一样的。此题中的计算顺序为1，2，4，3。即现计算（）内的第一个x++，再计算第二个x++，计算完后此时（）内只有一个表达式，暂不计算他，而是遵循自右向左的扫描顺序跳转去计算优先级高的第四个x++，最后再去计算第三个x++。

小结：printf()中++x是现加现用，x++是所有的用后再加。printf()之外则是++x从左向右第一个运算符左右两边先都加上再以最大值计算依次向右推进。x++则是所有的x先不加，计算完后再加。

PS:(++x)这种作++x看；(x++)同x++。